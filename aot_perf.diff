diff --git a/ecmascript/compiler/aot_file/aot_file_info.h b/ecmascript/compiler/aot_file/aot_file_info.h
index dddb7c43ff81a420100ebd0d2af439260fadba83..e11fc6a61416c73987ead5320f9d09e43b017b84 100644
--- a/ecmascript/compiler/aot_file/aot_file_info.h
+++ b/ecmascript/compiler/aot_file/aot_file_info.h
@@ -20,6 +20,8 @@
 #include "ecmascript/compiler/aot_file/module_section_des.h"
 #include "ecmascript/compiler/bc_call_signature.h"
 #include "ecmascript/deoptimizer/calleeReg.h"
+#include <cstddef>
+#include <cstring>
 
 namespace panda::ecmascript {
 class PUBLIC_API AOTFileInfo {
@@ -46,6 +48,8 @@ public:
         uint32_t funcSize_ {};
         uint32_t calleeRegisterNum_ {};
         int32_t CalleeReg2Offset_[2 * kungfu::MAX_CALLEE_SAVE_REIGISTER_NUM];
+        char name_[25];
+       bool hasName_;
         bool IsStub() const
         {
             return CallSignature::TargetKind::STUB_BEGIN <= kind_ && kind_ < CallSignature::TargetKind::STUB_END;
@@ -110,8 +114,8 @@ public:
     }
 
     void AddEntry(CallSignature::TargetKind kind, bool isMainFunc, bool isFastCall, int indexInKind, uint64_t offset,
-                  uint32_t moduleIndex, int delta, uint32_t size, CalleeRegAndOffsetVec info = {})
-    {
+                  uint32_t moduleIndex, int delta, uint32_t size, CalleeRegAndOffsetVec info = {}, const char* name = nullptr)
+    { 
         FuncEntryDes des;
         if (memset_s(&des, sizeof(des), 0, sizeof(des)) != EOK) {
             LOG_FULL(FATAL) << "memset_s failed";
@@ -126,6 +130,13 @@ public:
         des.fpDeltaPrevFrameSp_ = delta;
         des.funcSize_ = size;
         des.calleeRegisterNum_ = info.size();
+        des.hasName_ = false;
+        memset(des.name_, 0, sizeof(des.name_));
+        if(name != nullptr) {
+          std::strncpy(des.name_, name, 24);
+          des.name_[24] = 0;
+          des.hasName_ = true;
+        }
         DwarfRegType reg = 0;
         OffsetType regOffset = 0;
         for (size_t i = 0; i < info.size(); i++) {
diff --git a/ecmascript/compiler/aot_file/stub_file_info.cpp b/ecmascript/compiler/aot_file/stub_file_info.cpp
index 5fabb372fccc8584664f47c02095518c0aa52c8a..0aff0d8128150a4390ee541b3eb8580076e1fc3c 100644
--- a/ecmascript/compiler/aot_file/stub_file_info.cpp
+++ b/ecmascript/compiler/aot_file/stub_file_info.cpp
@@ -18,8 +18,10 @@
 #include "ecmascript/compiler/aot_file/elf_builder.h"
 #include "ecmascript/compiler/aot_file/elf_reader.h"
 #include "ecmascript/compiler/binary_section.h"
+#include "ecmascript/compiler/call_signature.h"
 #include "ecmascript/js_file_path.h"
 #include "ecmascript/platform/file.h"
+#include "foundation/resourceschedule/ffrt/src/internal_inc/osal.h"
 
 extern const uint8_t _binary_stub_an_start[];
 extern const uint32_t _binary_stub_an_length;
@@ -115,6 +117,8 @@ bool StubFileInfo::Load()
         return false;
     }
 
+    FILE* perfMap = perf_map_open(GetPid());
+
     BinaryBufferParser binBufparser(const_cast<uint8_t *>(_binary_stub_an_start), _binary_stub_an_length);
     moduleNum_ = ASMSTUB_MODULE_NUM;
     des_.resize(moduleNum_);
@@ -144,9 +148,15 @@ bool StubFileInfo::Load()
             auto moduleDes = des_[entry.moduleIndex_];
             entry.codeAddr_ += moduleDes.GetSecAddr(ElfSecName::TEXT);
         }
+        if(entry.hasName_) {
+            char buffer[50];
+            sprintf(buffer, "%s_%s",kungfu::CallSignature::TargetKind2String(entry.kind_),entry.name_);
+            perf_map_write_entry(perfMap, (void *)entry.codeAddr_, entry.funcSize_, buffer);
+        }
     }
     LOG_COMPILER(INFO) << "loaded stub file successfully";
     PageProtect(stubsMem_.addr_, stubsMem_.size_, PAGE_PROT_EXEC_READ);
+    perf_map_close(perfMap);
     return true;
 }
 
diff --git a/ecmascript/compiler/aot_file/stub_file_info.h b/ecmascript/compiler/aot_file/stub_file_info.h
index ce69103a1ac6c178bb890dccd733bcfa27f1366c..b111d8ded625e2651e9876a1bed9d141f43bf370 100644
--- a/ecmascript/compiler/aot_file/stub_file_info.h
+++ b/ecmascript/compiler/aot_file/stub_file_info.h
@@ -74,6 +74,31 @@ public:
 
     void Dump() const DUMP_API_ATTR;
 
+    FILE *perf_map_open(pid_t pid) {
+        char filename[500];
+        snprintf(filename, sizeof(filename), "/tmp/perf-%d.map", pid);
+        FILE * res = fopen(filename, "w");
+        if (!res) {
+            fprintf(stderr, "Couldn't open %s: errno(%d)", filename, errno);
+            exit(0);
+        }
+        return res;
+    }
+
+    int perf_map_close(FILE *fp) {
+    if (fp)
+        return fclose(fp);
+    else
+        return 0;
+    }
+
+    void perf_map_write_entry(FILE *method_file, const void* code_addr, unsigned int code_size, const char* entry) {
+        if (method_file)
+            fprintf(method_file, "%lx %x %s\n", (unsigned long) code_addr, code_size, entry);
+    }
+
+
+
 private:
     static constexpr uint32_t ASMSTUB_MODULE_NUM = 3;
 
diff --git a/ecmascript/compiler/call_signature.h b/ecmascript/compiler/call_signature.h
index a0c47c0e7da37a79d22306dda5b5ebcc61de1638..4e32d6880ae18e9c436c390652ecc9bafd0d9d15 100644
--- a/ecmascript/compiler/call_signature.h
+++ b/ecmascript/compiler/call_signature.h
@@ -305,7 +305,25 @@ public:
     {
         id_ = id;
     }
-
+static const char * TargetKind2String(TargetKind value) {
+        static const char * strs[] = {
+            "COMMON_STUB",
+            "RUNTIME_STUB",
+            "RUNTIME_STUB_VARARGS",
+            "RUNTIME_STUB_NO_GC",
+            "OPTIMIZED_STUB",
+            "OPTIMIZED_FAST_CALL_STUB",
+            "DEOPT_STUB",
+            "BYTECODE_HANDLER",
+            "BYTECODE_DEBUGGER_HANDLER",
+            "BYTECODE_HELPER_HANDLER",
+            "BYTECODE_PROFILE_HANDLER",
+            "JSFUNCTION",
+            "BUILTINS_STUB",
+            "BUILTINS_WITH_ARGV_STUB",
+        };
+        return strs[(int) value];
+    };
 private:
     std::string name_;
     size_t paramCounter_ {0};
diff --git a/ecmascript/compiler/file_generators.cpp b/ecmascript/compiler/file_generators.cpp
index e58c3afdd536c2d4f1ab627b39542e7260f8b82d..8f868ef23c36b3307fc6f8ad5bb40c49fe0e4001 100644
--- a/ecmascript/compiler/file_generators.cpp
+++ b/ecmascript/compiler/file_generators.cpp
@@ -93,8 +93,12 @@ void Module::CollectFuncEntryInfo(std::map<uintptr_t, std::string> &addr2name, S
             funcSize = codeBuff + assembler_->GetSectionSize(ElfSecName::TEXT) - entrys[j];
         }
         kungfu::CalleeRegAndOffsetVec info = assembler_->GetCalleeReg2Offset(func, log);
+        char buffer[50];
+        const char* pos = std::strrchr(cs->GetName().c_str(), '_');
+        std::strncpy(buffer, pos+1, 49);
+
         stubInfo.AddEntry(cs->GetTargetKind(), false, false, cs->GetID(), entrys[j] - codeBuff, moduleIndex, delta,
-                          funcSize, info);
+                          funcSize, info, buffer);
         ASSERT(!cs->GetName().empty());
         addr2name[entrys[j]] = cs->GetName();
     }
@@ -229,7 +233,10 @@ void StubFileGenerator::CollectAsmStubCodeInfo(std::map<uintptr_t, std::string>
         } else {
             funSize = asmModule_.GetBufferSize() - entryOffset;
         }
-        stubInfo_.AddEntry(cs->GetTargetKind(), false, false, cs->GetID(), entryOffset, bridgeModuleIdx, 0, funSize);
+        char buffer[50];
+        std::strncpy(buffer, cs->GetName().c_str(), 49);
+
+        stubInfo_.AddEntry(cs->GetTargetKind(), false, false, cs->GetID(), entryOffset, bridgeModuleIdx, 0, funSize,{},buffer);
         ASSERT(!cs->GetName().empty());
         addr2name[entryOffset] = cs->GetName();
     }
